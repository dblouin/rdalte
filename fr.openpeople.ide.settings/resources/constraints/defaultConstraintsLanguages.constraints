<?xml version="1.0" encoding="ASCII"?>
<cst:ConstraintLanguagesSpecification xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:cst="http:///fr/labsticc/framework/constraints" id="20903345" name="Default">
  <languages xsi:type="cst:NaturalConstraintLanguage" id="fr.labsticc.framework.constraints.core.natural" name="Natural"/>
  <languages xsi:type="cst:FormalConstraintLanguage" id="fr.labsticc.framework.constraints.ocl" name="OCL" description="">
    <libraries id="platform:/config/fr.openpeople.ide.settings/ocl/default/libComponent.ocl" name="libComponent.ocl" default="true">
      <expression id="51813c28-09f5-4d84-bb9a-9ddc6d0f953e" language="fr.labsticc.framework.constraints.ocl" text="-- *****************************************************************************************&#xD;&#xA;-- ** Copyright (c) 2009 Lab-STICC, Universit&#xef;&#xbf;&#xbd; de Bretagne-Sud.                           **&#xD;&#xA;-- ** All rights reserved. This program and the accompanying materials                    **&#xD;&#xA;-- ** are made available under the terms of the CeCILL-B FREE SOFTWARE LICENSE AGREEMENT  **&#xD;&#xA;-- ** which accompanies this distribution, and is available at                            **&#xD;&#xA;-- ** http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html                         **&#xD;&#xA;-- **                                                                                     **&#xD;&#xA;-- ** Contributors:                                                                       **&#xD;&#xA;-- **   Dominique BLOUIN (Lab-STICC, UBS)                                                 **&#xD;&#xA;-- *****************************************************************************************&#xD;&#xA;&#xD;&#xA;package aadl2&#xD;&#xA;&#xD;&#xA;context ComponentClassifier def : isOfTypeByName( p_type : String ) :&#xD;&#xA;&#x9;Boolean =&#xD;&#xA;&#x9;&#x9;let&#xD;&#xA;&#x9;&#x9;&#x9;qualName : String = qualifiedName()&#xD;&#xA;&#x9;&#x9;in&#xD;&#xA;&#x9;&#x9;&#x9;if qualName.oclIsUndefined() then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;false&#xD;&#xA;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if oclIsKindOf( ComponentImplementation ) then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;--typePlusDot.size() &lt;= getQualifiedName().size() and name.substring( 1, typePlusDot.size() ) = typePlusDot&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;qualName.substring( 1, p_type.size() + 1 ) = p_type&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;qualName = p_type&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context ComponentType def : isOfType( p_type : String ) :&#xD;&#xA;&#x9;Boolean =&#xD;&#xA;&#x9;&#x9;if isOfTypeByName( p_type ) then&#xD;&#xA;&#x9;&#x9;&#x9;true&#xD;&#xA;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;if extended.oclIsUndefined() then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;false&#xD;&#xA;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;extended.isOfType( p_type )&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context ComponentImplementation def : isOfType( p_type : String ) :&#xD;&#xA;&#x9;Boolean =&#xD;&#xA;&#x9;&#x9;if isOfTypeByName( p_type ) then&#xD;&#xA;&#x9;&#x9;&#x9;true&#xD;&#xA;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;if type.isOfType( p_type ) then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;true&#xD;&#xA;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if extended.oclIsUndefined() then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;false&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;extended.isOfType( p_type )&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context aadl2::ComponentClassifier def : isOfType( p_type : String ) :&#xD;&#xA;&#x9;Boolean =&#xD;&#xA;&#x9;&#x9;if oclIsKindOf( ComponentType ) then&#xD;&#xA;&#x9;&#x9;&#x9;oclAsType( ComponentType ).isOfType( p_type )&#xD;&#xA;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;oclAsType( ComponentImplementation ).isOfType( p_type )&#xD;&#xA;&#x9;&#x9;endif&#x9;&#x9;&#x9;&#xD;&#xA;&#xD;&#xA;context Subcomponent def : isOfType( p_type : String ) :&#xD;&#xA;&#x9;Boolean =&#xD;&#xA;&#x9;&#x9;if oclIsKindOf( ProcessorSubcomponent ) then&#xD;&#xA;&#x9;&#x9;&#x9;oclAsType( ProcessorSubcomponent ).classifier.isOfType( p_type )&#xD;&#xA;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;if oclIsKindOf( DeviceSubcomponent ) then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;oclAsType( DeviceSubcomponent ).classifier.isOfType( p_type )&#xD;&#xA;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if oclIsKindOf( SystemSubcomponent ) then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;oclAsType( SystemSubcomponent ).classifier.isOfType( p_type )&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if oclIsKindOf( DataSubcomponent ) then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;oclAsType( DataSubcomponent ).classifier.isOfType( p_type )&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if oclIsKindOf( ThreadSubcomponent ) then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;oclAsType( ThreadSubcomponent ).classifier.isOfType( p_type )&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if oclIsKindOf( ThreadGroupSubcomponent ) then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;oclAsType( ThreadGroupSubcomponent ).classifier.isOfType( p_type )&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if oclIsKindOf( ProcessSubcomponent ) then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;oclAsType( ProcessSubcomponent ).classifier.isOfType( p_type )&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if oclIsKindOf( SubprogramSubcomponent ) then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;oclAsType( SubprogramSubcomponent ).classifier.isOfType( p_type )&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if oclIsKindOf( MemorySubcomponent ) then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;oclAsType( MemorySubcomponent ).classifier.isOfType( p_type )&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if oclIsKindOf( BusSubcomponent ) then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;oclAsType( BusSubcomponent ).classifier.isOfType( p_type )&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;false&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : isOfType( p_type : String ) :&#xD;&#xA;&#x9;Boolean = subcomponent.isOfType( p_type )&#xD;&#xA;&#xD;&#xA;context AadlPackage def : processorTypes() : &#xD;&#xA;&#x9;Set( Classifier ) = &#xD;&#xA;&#x9;&#x9;ownedPublicSection.ownedClassifier->select( oclIsKindOf( ProcessorType) )->&#xD;&#xA;&#x9;&#x9;&#x9;union( ownedPrivateSection.ownedClassifier->select( oclIsKindOf( ProcessorType ) ) )->flatten()&#xD;&#xA;&#xD;&#xA;context AadlPackage def : processorImplementations() : &#xD;&#xA;&#x9;Set( Classifier ) = &#xD;&#xA;&#x9;&#x9;ownedPublicSection.ownedClassifier->select( oclIsKindOf( ProcessorImplementation ) )->&#xD;&#xA;&#x9;&#x9;&#x9;union( ownedPrivateSection.ownedClassifier->select( oclIsKindOf( ProcessorImplementation ) ) )->flatten()&#xD;&#xA;&#xD;&#xA;--/**&#xD;&#xA;-- * Return a boolean telling if this component instance is of the specified category.&#xD;&#xA;-- * @param p_category The name of the category.&#xD;&#xA;-- * @return A boolean value. True if null is passed for the category.&#xD;&#xA;-- */&#xD;&#xA;context instance::ComponentInstance def : isOfCategory( p_category : ComponentCategory ) :&#xD;&#xA;&#x9;Boolean = &#xD;&#xA;&#x9;&#x9;if p_category.oclIsUndefined() then&#xD;&#xA;&#x9;&#x9;&#x9;true&#xD;&#xA;&#x9;&#x9;else &#xD;&#xA;&#x9;&#x9;&#x9;category = p_category&#xD;&#xA;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : isData() :&#xD;&#xA;&#x9;Boolean = category = ComponentCategory::data&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : isSubprogram() :&#xD;&#xA;&#x9;Boolean = category = ComponentCategory::subprogram&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : isThread() :&#xD;&#xA;&#x9;Boolean = category = ComponentCategory::thread&#xD;&#xA;&#xD;&#xA;-- FIXME&#xD;&#xA;--context instance::ComponentInstance def : isThreadGroup() :&#xD;&#xA;&#x9;--Boolean = category = ComponentCategory::thread group&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : isProcess() :&#xD;&#xA;&#x9;Boolean = category = ComponentCategory::process&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : isMemory() :&#xD;&#xA;&#x9;Boolean = category = ComponentCategory::memory&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : isProcessor() :&#xD;&#xA;&#x9;Boolean = category = ComponentCategory::processor&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : isBus() :&#xD;&#xA;&#x9;Boolean = category = ComponentCategory::bus&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : isDevice() :&#xD;&#xA;&#x9;Boolean = category = ComponentCategory::device&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : isSystem() :&#xD;&#xA;&#x9;Boolean = category = ComponentCategory::system&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : allContainedComponents( p_category : ComponentCategory ) :&#xD;&#xA;&#x9;Set( instance::ComponentInstance ) = &#xD;&#xA;&#x9;&#x9;componentInstance->select( isOfCategory( p_category ) )->union( componentInstance->collect( allContainedComponents( p_category ) )->flatten()->asSet() )->flatten()&#xD;&#xA;&#xD;&#xA;context ecore::EObject def : parent() :&#xD;&#xA;&#x9;ecore::EObject = eContainer()&#xD;&#xA;&#xD;&#xA;context ecore::EObject def : rootParent() :&#xD;&#xA;&#x9;ecore::EObject = &#xD;&#xA;&#x9;&#x9;let&#xD;&#xA;&#x9;&#x9;&#x9;parent : ecore::EObject = parent()&#xD;&#xA;&#x9;&#x9;in&#xD;&#xA;&#x9;&#x9;&#x9;if parent.oclIsUndefined() then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;self&#xD;&#xA;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;parent.rootParent()&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#xD;&#xA;context ecore::EObject def : isContainedBy( p_container : ecore::EObject ) :&#xD;&#xA;&#x9;Boolean =&#xD;&#xA;&#x9;&#x9;let&#xD;&#xA;&#x9;&#x9;&#x9;parent : ecore::EObject = parent()&#xD;&#xA;&#x9;&#x9;in&#xD;&#xA;&#x9;&#x9;&#x9;if parent.oclIsUndefined() then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;false&#xD;&#xA;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if parent = p_container then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;true&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;parent.isContainedBy( p_container )&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context Element def : parent() :&#xD;&#xA;&#x9;ecore::EObject = oclAsType( ecore::EObject ).parent()&#xD;&#xA;&#xD;&#xA;context Element def : rootParent() :&#xD;&#xA;&#x9;ecore::EObject = oclAsType( ecore::EObject ).rootParent()&#xD;&#xA;&#xD;&#xA;context Element def : isContainedBy( p_container : Element ) :&#xD;&#xA;&#x9;Boolean = &#xD;&#xA;&#x9;&#x9;oclAsType( ecore::EObject ).isContainedBy( p_container.oclAsType( ecore::EObject ) )&#xD;&#xA;&#xD;&#xA;context Element def : allSubcomponents() :&#xD;&#xA;&#x9;Set( Element ) =&#xD;&#xA;&#x9;&#x9;if oclIsKindOf( instance::ComponentInstance ) then &#xD;&#xA;&#x9;&#x9;&#x9;oclAsType(  instance::ComponentInstance ).componentInstance&#xD;&#xA;&#x9;&#x9;else &#xD;&#xA;&#x9;&#x9;&#x9;if oclIsKindOf( ComponentImplementation ) then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;oclAsType( ComponentImplementation ).getAllSubcomponents()&#xD;&#xA;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;Set{}&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#x9;&#x9;endif&#x9;&#x9;&#x9;&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;endpackage"/>
    </libraries>
    <libraries id="platform:/config/fr.openpeople.ide.settings/ocl/default/libProperty.ocl" name="libProperty.ocl" default="true">
      <expression id="dbe77082-1a41-447f-905c-211491b32f7d" language="fr.labsticc.framework.constraints.ocl" text="-- *****************************************************************************************&#xD;&#xA;-- ** Copyright (c) 2009 Lab-STICC, Universit&#xe9; de Bretagne-Sud.                           **&#xD;&#xA;-- ** All rights reserved. This program and the accompanying materials                    **&#xD;&#xA;-- ** are made available under the terms of the CeCILL-B FREE SOFTWARE LICENSE AGREEMENT  **&#xD;&#xA;-- ** which accompanies this distribution, and is available at                            **&#xD;&#xA;-- ** http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html                         **&#xD;&#xA;-- **                                                                                     **&#xD;&#xA;-- ** Contributors:                                                                       **&#xD;&#xA;-- **   Dominique BLOUIN (Lab-STICC, UBS)                                                 **&#xD;&#xA;-- **   Jie LIAN (Lab-STICC, UBS)                                                    &#x9;  **&#xD;&#xA;-- *****************************************************************************************&#xD;&#xA;&#xD;&#xA;package aadl2&#xD;&#xA;&#xD;&#xA;----------------------------------------- Queries for Generic Properties ------------------------------------------------ &#xD;&#xA;--context Element def : allPropertyAssociations( &#x9;p_propertySetName : String,&#xD;&#xA;--&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName :  String ) :&#xD;&#xA;&#x9;--OrderedSet( PropertyAssociation ) =&#xD;&#xA;&#x9;&#x9;--PropertyAssociation.allInstances()->select( property.name = p_propertyName )->&#xD;&#xA;&#x9;&#x9;&#x9;--select( property.oclAsType( ecore::EObject ).eContainer().oclAsType( PropertySet ).name = p_propertySetName )->&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;--asOrderedSet()&#xD;&#xA;&#xD;&#xA;--context NamedElement def : property( &#x9;p_propertySetName : String,&#xD;&#xA;--&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) : &#xD;&#xA;&#x9;--Property = &#xD;&#xA;&#x9;--&#x9;PropertySet.allInstances()->select( name = p_propertySetName )->asOrderedSet()->first().&#xD;&#xA;&#x9;&#x9;--&#x9;ownedProperty->select( name = p_propertyName )->asOrderedSet()->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def : propertyValues( &#x9;p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;OrderedSet( PropertyExpression ) = &#xD;&#xA;&#x9;&#x9;getPropertyValues( p_propertySetName, p_propertyName )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;context NamedElement def : integerPropertyValues( &#x9;p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;OrderedSet( IntegerLiteral ) = &#xD;&#xA;&#x9;&#x9;propertyValues( p_propertySetName, p_propertyName )->collect( oclAsType( IntegerLiteral ) )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;context NamedElement def : integerRangePropertyValues( &#x9;p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;OrderedSet( RangeValue ) = &#xD;&#xA;&#x9;&#x9;propertyValues( p_propertySetName, p_propertyName )->collect( oclAsType( RangeValue ) )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;context NamedElement def : integerRangeMaxPropertyValues( &#x9;p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;OrderedSet( IntegerLiteral ) = &#xD;&#xA;&#x9;&#x9;integerRangePropertyValues( p_propertySetName, p_propertyName )->collect( maximum.oclAsType( IntegerLiteral ) )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;context NamedElement def : integerRangeMinPropertyValues( &#x9;p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;OrderedSet( IntegerLiteral ) = &#xD;&#xA;&#x9;&#x9;integerRangePropertyValues( p_propertySetName, p_propertyName )->collect( minimum.oclAsType( IntegerLiteral ) )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;context NamedElement def : stringPropertyValues( &#x9;p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;OrderedSet( String ) = &#xD;&#xA;&#x9;&#x9;propertyValues( p_propertySetName, p_propertyName )->collect( oclAsType( String ) )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;context NamedElement def : instanceReferencePropertyValues( p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;OrderedSet( instance::InstanceReferenceValue ) = &#xD;&#xA;&#x9;&#x9;propertyValues( p_propertySetName, p_propertyName )->collect( oclAsType( instance::InstanceReferenceValue ) )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;context NamedElement def : instanceObjectPropertyValues( &#x9;p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;OrderedSet( NamedElement ) = &#xD;&#xA;&#x9;&#x9;instanceReferencePropertyValues( p_propertySetName, p_propertyName )->collect( referencedInstanceObject )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;context NamedElement def : realPropertyValues( &#x9;p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;OrderedSet( RealLiteral ) = &#xD;&#xA;&#x9;&#x9;propertyValues( p_propertySetName, p_propertyName )->collect( oclAsType( RealLiteral ) )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;context NamedElement def : realRangePropertyValues( p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;OrderedSet( RangeValue ) = &#xD;&#xA;&#x9;&#x9;propertyValues( p_propertySetName, p_propertyName )->collect( oclAsType( RangeValue ) )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;context NamedElement def : realRangeMaxPropertyValues( &#x9;p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;OrderedSet( RealLiteral ) = &#xD;&#xA;&#x9;&#x9;realRangePropertyValues( p_propertySetName, p_propertyName )->collect( maximum.oclAsType( RealLiteral ) )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;context NamedElement def : realRangeMinPropertyValues( &#x9;p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;OrderedSet( RealLiteral ) = &#xD;&#xA;&#x9;&#x9;realRangePropertyValues( p_propertySetName, p_propertyName )->collect( minimum.oclAsType( RealLiteral ) )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;context NamedElement def : firstRealRangeMinPropertyValue( &#x9;p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;RealLiteral = &#xD;&#xA;&#x9;&#x9;let&#xD;&#xA;&#x9;&#x9;&#x9;propVals : OrderedSet( RealLiteral ) = realRangeMinPropertyValues( p_propertySetName, p_propertyName )&#xD;&#xA;&#x9;&#x9;in&#xD;&#xA;&#x9;&#x9;&#x9;if propVals->isEmpty() then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;null&#xD;&#xA;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;propVals->first()&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context NamedElement def : firstRealRangeMaxPropertyValue( &#x9;p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;RealLiteral = &#xD;&#xA;&#x9;&#x9;let&#xD;&#xA;&#x9;&#x9;&#x9;propVals : OrderedSet( RealLiteral ) = realRangeMaxPropertyValues( p_propertySetName, p_propertyName )&#xD;&#xA;&#x9;&#x9;in&#xD;&#xA;&#x9;&#x9;&#x9;if propVals->isEmpty() then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;null&#xD;&#xA;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;propVals->first()&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context NamedElement def : integerValues( &#x9;p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;OrderedSet( Integer ) = integerPropertyValues( p_propertySetName, p_propertyName )->&#xD;&#xA;&#x9;&#x9;collect( value * 1 )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;context NamedElement def : realValues( &#x9;p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName :  String ) :&#xD;&#xA;&#x9;OrderedSet( Real ) = realPropertyValues( p_propertySetName, p_propertyName )->&#xD;&#xA;&#x9;&#x9;collect( value )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;context NamedElement def : realRangeMaxValues( &#x9;p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;OrderedSet( Real ) = &#xD;&#xA;&#x9;&#x9;-- FIXME: Manage property reference&#xD;&#xA;&#x9;&#x9;realRangePropertyValues( p_propertySetName, p_propertyName )->collect( maximum.oclAsType( RealLiteral ).value )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;context NamedElement def : realRangeMinValues( &#x9;p_propertySetName : String,&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;p_propertyName : String ) :&#xD;&#xA;&#x9;OrderedSet( Real ) = &#xD;&#xA;&#x9;&#x9;-- FIXME: Manage property reference&#xD;&#xA;&#x9;&#x9;realRangePropertyValues( p_propertySetName, p_propertyName )->collect( minimum.oclAsType( RealLiteral ).value )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;----------------------------------------- Property Constants ------------------------------------------------ &#xD;&#xA;context NamedElement def : aadlProjectPropertySetName() : &#xD;&#xA;&#x9;String = 'AADL_Project'&#xD;&#xA;&#xD;&#xA;context NamedElement def : communicationPropertiesPropertySetName() : &#xD;&#xA;&#x9;String = 'Communication_Properties'&#xD;&#xA;&#xD;&#xA;context NamedElement def : deploymentPropertiesPropertySetName() : &#xD;&#xA;&#x9;String = 'Deployment_Properties'&#xD;&#xA;&#xD;&#xA;context NamedElement def : memoryPropertiesPropertySetName() : &#xD;&#xA;&#x9;String = 'Memory_Properties'&#xD;&#xA;&#xD;&#xA;context NamedElement def : modelingPropertiesPropertySetName() : &#xD;&#xA;&#x9;String = 'Modeling_Properties'&#xD;&#xA;&#xD;&#xA;context NamedElement def : programmingPropertiesPropertySetName() : &#xD;&#xA;&#x9;String = 'Programming_Properties'&#xD;&#xA;&#xD;&#xA;context NamedElement def : threadPropertiesPropertySetName() : &#xD;&#xA;&#x9;String = 'Thread_Properties'&#xD;&#xA;&#xD;&#xA;context NamedElement def : timingPropertiesPropertySetName() : &#xD;&#xA;&#x9;String = 'Timing_Properties'&#xD;&#xA;&#xD;&#xA;context NamedElement def : seiPropertySetName() : &#xD;&#xA;&#x9;String = 'SEI'&#xD;&#xA;&#xD;&#xA;-------------------- AADL Project ------------------------&#xD;&#xA;context NamedElement def : dataVolumeName() :&#xD;&#xA;&#x9;String='Data_Volume'&#xD;&#xA;&#xD;&#xA;-------------------- Timing ------------------------&#xD;&#xA;context NamedElement def : activateDeadlineName() :&#xD;&#xA;&#x9;String ='Activate_Deadline'&#xD;&#xA;&#xD;&#xA;context NamedElement def : activateExecutionTimeName() :&#xD;&#xA;&#x9;String='Activate_Execution_Time'&#xD;&#xA;&#xD;&#xA;context NamedElement def : clientSubprogramExecutionTimeName() :&#xD;&#xA;&#x9;String='Client_Subprogram_Execution_Time'&#xD;&#xA;&#xD;&#xA;context NamedElement def : clockJitterName() :&#xD;&#xA;&#x9;String='Clock_Jitter'&#xD;&#xA;&#xD;&#xA;context NamedElement def : clockPeriodName() :&#xD;&#xA;&#x9;String='Clock_Period'&#xD;&#xA;&#xD;&#xA;context NamedElement def : clockPeriodRangeName() :&#xD;&#xA;&#x9;String='Clock_Period_Range'&#xD;&#xA;&#xD;&#xA;context NamedElement def : computeDeadlineName() :&#xD;&#xA;&#x9;String='Compute_Deadline'&#xD;&#xA;&#xD;&#xA;context NamedElement def : computeExecutionTimeName() : &#xD;&#xA;&#x9;String = 'Compute_Execution_Time'&#xD;&#xA;&#xD;&#xA;context NamedElement def : deactivateExecutionTimeName() :&#xD;&#xA;&#x9;String='Deactivate_Execution_Time'&#xD;&#xA;&#xD;&#xA;context NamedElement def : deadlineName() :&#xD;&#xA;&#x9;String='Deadline'&#xD;&#xA;&#xD;&#xA;context NamedElement def : finalizeDeadlineName() :&#xD;&#xA;&#x9;String='Finalize_Deadline'&#xD;&#xA;&#xD;&#xA;context NamedElement def : finalizeExecutionTimeName() :&#xD;&#xA;&#x9;String='Finalize_Execution_Time'&#xD;&#xA;&#xD;&#xA;context NamedElement def :initializeDeadlineName() :&#xD;&#xA;&#x9;String='Initialize_Deadline'&#xD;&#xA;&#xD;&#xA;context NamedElement def : initializeExecutionTimeName() :&#xD;&#xA;&#x9;String='Initialize_Execution_Time'&#xD;&#xA;&#xD;&#xA;context NamedElement def : loadDeadlineName() :&#xD;&#xA;&#x9;String='Load_Deadline'&#xD;&#xA;&#xD;&#xA;context NamedElement def : loadTimeName() :&#xD;&#xA;&#x9;String='Load_Time'&#xD;&#xA;&#xD;&#xA;context NamedElement def : periodName() : &#xD;&#xA;&#x9;String = 'Period'&#xD;&#xA;&#xD;&#xA;context NamedElement def : processSwapExecutionTimeName() :&#xD;&#xA;&#x9;String='Process_Swap_Execution_Time'&#xD;&#xA;&#xD;&#xA;context NamedElement def : recoverDeadlineName() :&#xD;&#xA;&#x9;String='Recover_Deadline'&#xD;&#xA;&#xD;&#xA;context NamedElement def : recoverExecutionTimeName() :&#xD;&#xA;&#x9;String='Recover_Execution_Time'&#xD;&#xA;&#xD;&#xA;context NamedElement def : startupDeadlineName() :&#xD;&#xA;&#x9;String='Startup_Deadline'&#xD;&#xA;&#xD;&#xA;context NamedElement def : subprogramExecutionTimeName() :&#xD;&#xA;&#x9;String='Subprogram_Execution_Time'&#xD;&#xA;&#xD;&#xA;context NamedElement def : threadSwapExecutionTimeName() :&#xD;&#xA;&#x9;String='Thread_Swap_Execution_Time'&#xD;&#xA;&#xD;&#xA;-------------------- Programming ------------------------&#xD;&#xA;context NamedElement def : activateEntrypointName() :&#xD;&#xA;&#x9;String='Activate_Entrypoint'&#xD;&#xA;&#xD;&#xA;context NamedElement def : computeEntrypointName() :&#xD;&#xA;&#x9;String='Compute_Entrypoint'&#xD;&#xA;&#xD;&#xA;context NamedElement def : deactivateEntrypointName() :&#xD;&#xA;&#x9;String='Deactivate_Entrypoint'&#xD;&#xA;&#xD;&#xA;context NamedElement def : hardwareDescriptionSourceTextName() :&#xD;&#xA;&#x9;String='Hardware_Description_Source_Text'&#xD;&#xA;&#xD;&#xA;context NamedElement def : hardwareSourceLanguageName() :&#xD;&#xA;&#x9;String='Hardware_Source_Language'&#xD;&#xA;&#xD;&#xA;context NamedElement def : initializeEntrypointName() :&#xD;&#xA;&#x9;String='Initialize_Entrypoint'&#xD;&#xA;&#xD;&#xA;context NamedElement def : sourceLanguageName() :&#xD;&#xA;&#x9;String='Source_Language'&#xD;&#xA;&#xD;&#xA;context NamedElement def : sourceNameName() :&#xD;&#xA;&#x9;String='Source_Name'&#xD;&#xA;&#xD;&#xA;context NamedElement def : sourceTextName() :&#xD;&#xA;&#x9;String='Source_Text'&#xD;&#xA;&#xD;&#xA;context NamedElement def : supportedSourceLanguageName() :&#xD;&#xA;&#x9;String='Supported_Source_Language'&#xD;&#xA;&#xD;&#xA;context NamedElement def : typeSourceNameName() :&#xD;&#xA;&#x9;String='Type_Source_Name'&#xD;&#xA;&#xD;&#xA;-------------------- Thread ------------------------&#xD;&#xA;context NamedElement def : activeThreadHandlingProtocolName() :&#xD;&#xA;&#x9;String='Active_Thread_Handling_Protocol'&#xD;&#xA;&#xD;&#xA;context NamedElement def : activeThreadQueueHandlingProtocolName() :&#xD;&#xA;&#x9;String='Active_Thread_Queue_Handling_Protocol'&#xD;&#xA;&#xD;&#xA;context NamedElement def : concurrencyControlProtocolName() :&#xD;&#xA;&#x9;String='Concurrency_Control_Protocol'&#xD;&#xA;&#xD;&#xA;context NamedElement def : dequeueProtocolName() :&#xD;&#xA;&#x9;String='Dequeue_Protocol'&#xD;&#xA;&#xD;&#xA;context NamedElement def : dispatchProtocolName() :&#xD;&#xA;&#x9;String='Dispatch_Protocol'&#xD;&#xA;&#xD;&#xA;context NamedElement def : synchronizedComponentName() :&#xD;&#xA;&#x9;String='Synchronized_Component'&#xD;&#xA;&#xD;&#xA;context NamedElement def : urgencyName() :&#xD;&#xA;&#x9;String='Urgency'&#xD;&#xA;&#xD;&#xA;-------------------- Deployment ------------------------&#xD;&#xA;context NamedElement def : actualConnectionBindingName() :&#xD;&#xA;&#x9;String='Actual_Connection_Binding'&#xD;&#xA;&#xD;&#xA;context NamedElement def : actualMemoryBindingName() :&#xD;&#xA;&#x9;String='Actual_Memory_Binding'&#xD;&#xA;&#xD;&#xA;context NamedElement def : actualProcessorBindingName() :&#xD;&#xA;&#x9;String='Actual_Processor_Binding'&#xD;&#xA;&#xD;&#xA;context NamedElement def : actualSubprogramCallName() :&#xD;&#xA;&#x9;String='Actual_Subprogram_Call'&#xD;&#xA;&#xD;&#xA;context NamedElement def : actualSubprogramCallBindingName() :&#xD;&#xA;&#x9;String='Actual_Subprogram_Call_Binding'&#xD;&#xA;&#xD;&#xA;context NamedElement def : allowedConnectionBindingName() :&#xD;&#xA;&#x9;String='Allowed_Connection_Binding'&#xD;&#xA;&#xD;&#xA;context NamedElement def : allowedConnectionBindingClassName() :&#xD;&#xA;&#x9;String='Allowed_Connection_Binding_Class'&#xD;&#xA;&#xD;&#xA;context NamedElement def : allowedDispatchProtocolName() :&#xD;&#xA;&#x9;String='Allowed_Dispatch_Protocol'&#xD;&#xA;&#xD;&#xA;context NamedElement def : allowedMemoryBindingName() :&#xD;&#xA;&#x9;String='Allowed_Memory_Binding'&#xD;&#xA;&#xD;&#xA;context NamedElement def : allowedMemoryBindingClassName() :&#xD;&#xA;&#x9;String='Allowed_Memory_Binding_Class'&#xD;&#xA;&#xD;&#xA;context NamedElement def : allowedPeriodName() :&#xD;&#xA;&#x9;String='Allowed_Period'&#xD;&#xA;&#xD;&#xA;context NamedElement def : allowedProcessorBindingName() :&#xD;&#xA;&#x9;String='Allowed_Processor_Binding'&#xD;&#xA;&#xD;&#xA;context NamedElement def : allowedProcessorBindingClassName() :&#xD;&#xA;&#x9;String='Allowed_Processor_Binding_Class'&#xD;&#xA;&#xD;&#xA;context NamedElement def : allowedSubprogramCallName() :&#xD;&#xA;&#x9;String='Allowed_Subprogram_Call'&#xD;&#xA;&#xD;&#xA;context NamedElement def : allowedSubprogramCallBindingName() :&#xD;&#xA;&#x9;String='Allowed_Subprogram_Call_Binding'&#xD;&#xA;&#xD;&#xA;context NamedElement def : memoryProtocolName() :&#xD;&#xA;&#x9;String='Memory_Protocol'&#xD;&#xA;&#xD;&#xA;context NamedElement def : notCollocatedName() :&#xD;&#xA;&#x9;String='Not_Collocated'&#xD;&#xA;&#xD;&#xA;context NamedElement def : schedulingProtocolName() :&#xD;&#xA;&#x9;String='Scheduling_Protocol'&#xD;&#xA;&#xD;&#xA;context NamedElement def : threadLimitName() :&#xD;&#xA;&#x9;String='Thread_Limit'&#xD;&#xA;&#xD;&#xA;-------------------- Communication ------------------------&#xD;&#xA;context NamedElement def : actualLatencyName() :&#xD;&#xA;&#x9;String='Actual_Latency'&#xD;&#xA;&#xD;&#xA;context NamedElement def : latencyName() :&#xD;&#xA;&#x9;String='Latency'&#xD;&#xA;&#xD;&#xA;context NamedElement def : overflowHandlingProtocolName() :&#xD;&#xA;&#x9;String='Overflow_Handling_Protocol'&#xD;&#xA;&#xD;&#xA;context NamedElement def : queueProcessingProtocolName() :&#xD;&#xA;&#x9;String='Queue_Processing_Protocol'&#xD;&#xA;&#xD;&#xA;context NamedElement def : queueSizeName() :&#xD;&#xA;&#x9;String='Queue_Size'&#xD;&#xA;&#xD;&#xA;context NamedElement def : requiredConnectionName() :&#xD;&#xA;&#x9;String='Required_Connection'&#xD;&#xA;&#xD;&#xA;context NamedElement def : transmissionTimeName() :&#xD;&#xA;&#x9;String='Transmission_Time'&#xD;&#xA;&#xD;&#xA;-------------------- Memory ------------------------&#xD;&#xA;context NamedElement def : allowedMessageSizeName() :&#xD;&#xA;&#x9;String='Allowed_Message_Size'&#xD;&#xA;&#xD;&#xA;context NamedElement def : assignTimeName() :&#xD;&#xA;&#x9;String='Assign_Time'&#xD;&#xA;&#xD;&#xA;context NamedElement def : baseAddressName() :&#xD;&#xA;&#x9;String='Base_Address'&#xD;&#xA;&#xD;&#xA;context NamedElement def : deviceRegisterAddressName() :&#xD;&#xA;&#x9;String='Device_Register_Address'&#xD;&#xA;&#xD;&#xA;context NamedElement def : readTimeName() :&#xD;&#xA;&#x9;String='Read_Time'&#xD;&#xA;&#xD;&#xA;context NamedElement def : sourceCodeSizeName() :&#xD;&#xA;&#x9;String='Source_Code_Size'&#xD;&#xA;&#xD;&#xA;context NamedElement def : sourceDataSizeName() :&#xD;&#xA;&#x9;String='Source_Data_Size'&#xD;&#xA;&#xD;&#xA;context NamedElement def : sourceHeapSizeName() :&#xD;&#xA;&#x9;String='Source_Heap_Size'&#xD;&#xA;&#xD;&#xA;context NamedElement def : sourceStackSizeName() :&#xD;&#xA;&#x9;String='Source_Stack_Size'&#xD;&#xA;&#xD;&#xA;context NamedElement def : wordSizeName() :&#xD;&#xA;&#x9;String='Word_Size'&#xD;&#xA;&#xD;&#xA;context NamedElement def : wordSpaceName() :&#xD;&#xA;&#x9;String='Word_Space'&#xD;&#xA;&#xD;&#xA;context NamedElement def : writeTimeName() :&#xD;&#xA;&#x9;String='Write_Time'&#xD;&#xA;&#xD;&#xA;-------------------- SEI ------------------------&#xD;&#xA;context NamedElement def : securityLevelName() :&#xD;&#xA;&#x9;String = 'SecurityLevel'&#xD;&#xA;&#xD;&#xA;context NamedElement def : safetyCriticalityName() :&#xD;&#xA;&#x9;String = 'SafetyCriticality'&#xD;&#xA;&#xD;&#xA;context NamedElement def : streamMissRateName() :&#xD;&#xA;&#x9;String = 'StreamMissRate'&#xD;&#xA;&#xD;&#xA;context NamedElement def : netWeightName() :&#xD;&#xA;&#x9;String = 'NetWeight'&#xD;&#xA;&#xD;&#xA;context NamedElement def : grossWeightName() :&#xD;&#xA;&#x9;String = 'GrossWeight'&#xD;&#xA;&#xD;&#xA;context NamedElement def : weightLimitName() :&#xD;&#xA;&#x9;String = 'WeightLimit'&#xD;&#xA;&#xD;&#xA;context NamedElement def : weightUnitsName() :&#xD;&#xA;&#x9;String = 'WeightUnits'&#xD;&#xA;&#xD;&#xA;context NamedElement def : dataRepresentationName() :&#xD;&#xA;&#x9;String ='DataRepresentation'&#xD;&#xA;&#xD;&#xA;context NamedElement def : protocolQoSName() :&#xD;&#xA;&#x9;String ='ProtocolQoS'&#xD;&#xA;&#xD;&#xA;context NamedElement def : priorityName() :&#xD;&#xA;&#x9;String ='Priority' &#xD;&#xA;&#xD;&#xA;context NamedElement def : partitionLatencyName() :&#xD;&#xA;&#x9;String = 'Partition_Latency'&#xD;&#xA;&#xD;&#xA;context NamedElement def : isPartitionName() :&#xD;&#xA;&#x9;String = 'Is_Partition'&#xD;&#xA;&#xD;&#xA;context NamedElement def : referenceCycleTimeName() :&#xD;&#xA;&#x9;String ='reference_cycle_time'&#xD;&#xA;&#xD;&#xA;context NamedElement def : cycleTimeName() :&#xD;&#xA;&#x9;String ='cycle_time'&#xD;&#xA;&#xD;&#xA;context NamedElement def : referenceProcessorName() :&#xD;&#xA;&#x9;String ='reference_processor'&#xD;&#xA;&#xD;&#xA;context NamedElement def : speedScalingFactorName() :&#xD;&#xA;&#x9;String ='speed_scaling_factor'&#xD;&#xA;&#xD;&#xA;context NamedElement def : cyclesPerInstructionName() :&#xD;&#xA;&#x9;String= 'cycles_per_instruction'&#xD;&#xA;&#xD;&#xA;context NamedElement def : mipsCapacityName() : &#xD;&#xA;&#x9;String = 'MIPSCapacity'&#xD;&#xA;&#xD;&#xA;context NamedElement def : mipsBudgetName() :&#xD;&#xA;&#x9;String ='MIPSBudget'&#xD;&#xA;&#xD;&#xA;context NamedElement def : ramCapacityName() :&#xD;&#xA;&#x9;String ='RAMCapacity'&#xD;&#xA;&#xD;&#xA;context NamedElement def : ramBudgetName() :&#xD;&#xA;&#x9;String= 'RAMBudget'&#xD;&#xA;&#xD;&#xA;context NamedElement def : romCapacityName() :&#xD;&#xA;&#x9;String= 'ROMCapacity'&#xD;&#xA;&#xD;&#xA;context NamedElement def : romBudgetName () :&#xD;&#xA;&#x9;String ='ROMBudget'&#xD;&#xA;&#xD;&#xA;context NamedElement def : powerCapacityName() :&#xD;&#xA;&#x9;String ='PowerCapacity'&#xD;&#xA;&#xD;&#xA;context NamedElement def : powerBudgetName() :&#xD;&#xA;&#x9;String ='PowerBudget'&#xD;&#xA;&#xD;&#xA;context NamedElement def :powerSupplyName() :&#xD;&#xA;&#x9;String ='PowerSupply'&#xD;&#xA;&#xD;&#xA;context NamedElement def :bandWidthCapacityName() :&#xD;&#xA;&#x9;String ='BandWidthCapacity'&#xD;&#xA;&#xD;&#xA;context NamedElement def : ramActualName () :&#xD;&#xA;&#x9;String ='RAMActual'&#xD;&#xA;&#x9;&#xD;&#xA;context NamedElement def : romActualName () :&#xD;&#xA;&#x9;String ='ROMActual'&#xD;&#xA;&#xD;&#xA;----------------------------------------- Units ---------------------------------------------------- &#xD;&#xA;-- Units constants&#xD;&#xA;context NamedElement def : psUnit() :&#xD;&#xA;&#x9;String = 'ps'&#xD;&#xA;&#xD;&#xA;context NamedElement def : nsUnit() :&#xD;&#xA;&#x9;String = 'ns'&#xD;&#xA;&#xD;&#xA;context NamedElement def : usUnit() :&#xD;&#xA;&#x9;String = 'us'&#xD;&#xA;&#xD;&#xA;context NamedElement def : msUnit() :&#xD;&#xA;&#x9;String = 'ms'&#xD;&#xA;&#xD;&#xA;context NamedElement def : secUnit() :&#xD;&#xA;&#x9;String = 'sec'&#xD;&#xA;&#xD;&#xA;context NamedElement def : minUnit() :&#xD;&#xA;&#x9;String = 'min'&#xD;&#xA;&#xD;&#xA;context NamedElement def : hrUnit() :&#xD;&#xA;&#x9;String = 'hr'&#xD;&#xA;&#xD;&#xA;-- Size Units --------&#xD;&#xA;context NamedElement def : bitsUnit():&#xD;&#xA;&#x9;String = 'bits'&#xD;&#xA;&#xD;&#xA;context NamedElement def : bUnit():&#xD;&#xA;&#x9;String = 'Bytes'&#xD;&#xA;&#xD;&#xA;context NamedElement def : kbUnit():&#xD;&#xA;&#x9;String = 'KByte'&#xD;&#xA;&#xD;&#xA;context NamedElement def : mbUnit():&#xD;&#xA;&#x9;String = 'MByte'&#xD;&#xA;&#xD;&#xA;context NamedElement def : gbUnit():&#xD;&#xA;&#x9;String = 'GByte'&#xD;&#xA;&#xD;&#xA;context NamedElement def : tbUnit():&#xD;&#xA;&#x9;String = 'TByte'&#xD;&#xA;&#xD;&#xA;-- Units conversion functions&#xD;&#xA;--context NumberValue def : unitLiteral( p_unitName : String ) : &#xD;&#xA;&#x9;--UnitLiteral = &#xD;&#xA;&#x9;&#x9;--UnitLiteral.allInstances()->select( name = p_unitName )->asOrderedSet()->first()&#xD;&#xA;&#xD;&#xA;--context NumberValue def : convertedValue( p_unit : String ) :&#xD;&#xA;&#x9;--Real = &#xD;&#xA;&#x9;&#x9;--value * unit.getAbsoluteFactor( unitLiteral( p_unit ) )&#xD;&#xA;&#xD;&#xA;context NumberValue def : convertedValue( p_unit : String ) :&#xD;&#xA;&#x9;Real = &#xD;&#xA;&#x9;&#x9;getScaledValue( p_unit )&#xD;&#xA;&#xD;&#xA;----------------------------------------- Property Getters ------------------------------------------------ &#xD;&#xA;&#xD;&#xA;-------------------- AADL Project ------------------------&#xD;&#xA;context NamedElement def :dataVolume() :&#xD;&#xA;&#x9;Integer = integerValues( aadlProjectPropertySetName(), dataVolumeName() )->first()&#xD;&#xA;&#xD;&#xA;-------------------- Timing ------------------------&#xD;&#xA;context NamedElement def : activateDeadline( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerPropertyValues( timingPropertiesPropertySetName(), activateDeadlineName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def : activateExecutionTimeMax( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMaxPropertyValues( timingPropertiesPropertySetName(), activateExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :clientSubprogramExecutionTime( p_unit : String ):&#xD;&#xA;&#x9;Real = integerPropertyValues( timingPropertiesPropertySetName(), clientSubprogramExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :clockJitter() :&#xD;&#xA;&#x9;Integer = integerValues( timingPropertiesPropertySetName(), clockJitterName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :clockPeriod( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerPropertyValues( timingPropertiesPropertySetName(), clockPeriodName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :clockPeriodRangeMax( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMaxPropertyValues( timingPropertiesPropertySetName(), clockPeriodRangeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :clockPeriodRangeMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMinPropertyValues( timingPropertiesPropertySetName(), clockPeriodRangeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :computeDeadline() :&#xD;&#xA;&#x9;Integer = integerValues( timingPropertiesPropertySetName(), computeDeadlineName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def : computeExecutionTimeMax( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMaxPropertyValues( timingPropertiesPropertySetName(), computeExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def : computeExecutionTimeMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMinPropertyValues( timingPropertiesPropertySetName(), computeExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :deactivateExecutionTimeMax( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMaxPropertyValues( timingPropertiesPropertySetName(), deactivateExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :deactivateExecutionTimeMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMinPropertyValues( timingPropertiesPropertySetName(), deactivateExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :deadline() :&#xD;&#xA;&#x9;Integer = integerValues( timingPropertiesPropertySetName(), deadlineName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :finalizeDeadline() :&#xD;&#xA;&#x9;Integer = integerValues( timingPropertiesPropertySetName(), finalizeDeadlineName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :finalizeExecutionTimeMax( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMaxPropertyValues( timingPropertiesPropertySetName(), finalizeExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :finalizeExecutionTimeMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMinPropertyValues( timingPropertiesPropertySetName(), finalizeExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :initializeDeadline() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( timingPropertiesPropertySetName(), initializeDeadlineName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :initializeExecutionTimeMax( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMaxPropertyValues( timingPropertiesPropertySetName(), initializeExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :initializeExecutionTimeMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMinPropertyValues( timingPropertiesPropertySetName(), initializeExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :loadDeadline() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( timingPropertiesPropertySetName(), loadDeadlineName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :loadTimeMax( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMaxPropertyValues( timingPropertiesPropertySetName(), loadTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :loadTimeMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMinPropertyValues( timingPropertiesPropertySetName(), loadTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :period( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerPropertyValues( timingPropertiesPropertySetName(), periodName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :processSwapExecutionTimeMax( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMaxPropertyValues( timingPropertiesPropertySetName(), processSwapExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :processSwapExecutionTimeMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMinPropertyValues( timingPropertiesPropertySetName(), processSwapExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :recoverDeadline() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( timingPropertiesPropertySetName(), recoverDeadlineName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :recoverExecutionTimeMax( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMaxPropertyValues( timingPropertiesPropertySetName(), recoverExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :recoverExecutionTimeMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMinPropertyValues( timingPropertiesPropertySetName(), recoverExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :startupDeadline() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( timingPropertiesPropertySetName(), startupDeadlineName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :subprogramExecutionTimeMax( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMaxPropertyValues( timingPropertiesPropertySetName(), subprogramExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :subprogramExecutionTimeMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMinPropertyValues( timingPropertiesPropertySetName(), subprogramExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :threadSwapExecutionTimeMax( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMaxPropertyValues( timingPropertiesPropertySetName(), threadSwapExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :threadSwapExecutionTimeMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMinPropertyValues( timingPropertiesPropertySetName(), threadSwapExecutionTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;-------------------- Programming ------------------------&#xD;&#xA;context NamedElement def : activateEntrypoint() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( programmingPropertiesPropertySetName(), activateEntrypointName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :computeEntrypoint() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( programmingPropertiesPropertySetName(), computeEntrypointName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :deactivateEntrypoint() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( programmingPropertiesPropertySetName(), deactivateEntrypointName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :hardwareDescriptionSourceText() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( programmingPropertiesPropertySetName(), hardwareDescriptionSourceTextName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :hardwareSourceLanguage() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( programmingPropertiesPropertySetName(), hardwareSourceLanguageName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :initializeEntrypoint() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( programmingPropertiesPropertySetName(), initializeEntrypointName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :sourceLanguage() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( programmingPropertiesPropertySetName(), sourceLanguageName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :sourceName() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( programmingPropertiesPropertySetName(), sourceNameName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :sourceText() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( programmingPropertiesPropertySetName(), sourceTextName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :supportedSourceLanguage() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( programmingPropertiesPropertySetName(), supportedSourceLanguageName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :typeSourceName() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( programmingPropertiesPropertySetName(), typeSourceNameName())->first()&#xD;&#xA;&#xD;&#xA;-------------------- Thread ------------------------&#xD;&#xA;context NamedElement def : activeThreadHandlingProtocol() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( threadPropertiesPropertySetName(), activeThreadHandlingProtocolName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def : activeThreadQueueHandlingProtocol() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( threadPropertiesPropertySetName(), activeThreadQueueHandlingProtocolName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :concurrencyControlProtocol() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( threadPropertiesPropertySetName(), concurrencyControlProtocolName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :dequeueProtocol() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( threadPropertiesPropertySetName(), dequeueProtocolName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :dispatchProtocol() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( threadPropertiesPropertySetName(), dispatchProtocolName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :synchronizedComponent() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( threadPropertiesPropertySetName(), synchronizedComponentName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def : urgency() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( threadPropertiesPropertySetName(), urgencyName())->first()&#xD;&#xA;&#xD;&#xA;-------------------- Deployment ------------------------&#xD;&#xA;context NamedElement def : actualConnectionBinding() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), actualConnectionBindingName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def : actualMemoryBinding() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), actualMemoryBindingName())->first()&#xD;&#xA;&#xD;&#xA;context ComponentClassifier def : actualProcessorBinding() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), actualProcessorBindingName() )->first()&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : actualProcessorBinding() :&#xD;&#xA;&#x9;NamedElement = &#xD;&#xA;&#x9;&#x9;let&#xD;&#xA;&#x9;&#x9;&#x9;instValues : OrderedSet( NamedElement ) = instanceObjectPropertyValues( deploymentPropertiesPropertySetName(), actualProcessorBindingName() )&#xD;&#xA;&#x9;&#x9;in&#xD;&#xA;&#x9;&#x9;&#x9;if instValues->isEmpty() then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;null&#xD;&#xA;&#x9;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;instValues->first()&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context NamedElement def : actualSubprogramCall() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), actualSubprogramCallName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def : actualSubprogramCallBinding() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), actualSubprogramCallBindingName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :allowedConnectionBinding() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), allowedConnectionBindingName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :allowedConnectionBindingClass() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), allowedConnectionBindingClassName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :allowedDispatchProtocol() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), allowedDispatchProtocolName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :allowedMemoryBinding() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), allowedMemoryBindingName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :allowedMemoryBindingClass() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), allowedMemoryBindingClassName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :allowedPeriodMax( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMaxPropertyValues( deploymentPropertiesPropertySetName(), allowedPeriodName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :allowedPeriodMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMinPropertyValues( deploymentPropertiesPropertySetName(), allowedPeriodName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :allowedProcessorBinding() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), allowedProcessorBindingName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :allowedProcessorBindingClass() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), allowedProcessorBindingClassName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :allowedSubprogramCall() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), allowedSubprogramCallName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :allowedSubprogramCallBinding() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), allowedSubprogramCallBindingName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :memoryProtocol() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), memoryProtocolName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :notCollocated() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), notCollocatedName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :schedulingProtocol() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), schedulingProtocolName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :threadLimit() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( deploymentPropertiesPropertySetName(), threadLimitName())->first()&#xD;&#xA;&#xD;&#xA;-------------------- Communication ------------------------&#xD;&#xA;context NamedElement def :actualLatency() :&#xD;&#xA;&#x9;Integer = integerValues( communicationPropertiesPropertySetName(), actualLatencyName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :latency() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( communicationPropertiesPropertySetName(), latencyName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :overflowHandlingProtocol() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( communicationPropertiesPropertySetName(), overflowHandlingProtocolName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :queueProcessingProtocol() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( communicationPropertiesPropertySetName(), queueProcessingProtocolName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :queueSize() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( communicationPropertiesPropertySetName(), queueSizeName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :requiredConnection() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues( communicationPropertiesPropertySetName(), requiredConnectionName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :transmissionTimesMax( p_unit : String ) :&#xD;&#xA;&#x9;OrderedSet( Real ) = integerRangeMaxPropertyValues( communicationPropertiesPropertySetName(), transmissionTimeName() )->collect( convertedValue( p_unit ) )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;context NamedElement def :transmissionTimesMin( p_unit : String ) :&#xD;&#xA;&#x9;OrderedSet( Real ) = integerRangeMinPropertyValues( communicationPropertiesPropertySetName(), transmissionTimeName() )->collect( convertedValue( p_unit ) )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;-------------------- Memory ------------------------&#xD;&#xA;context NamedElement def :allowedMessageSizeMax( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMaxPropertyValues( memoryPropertiesPropertySetName(), allowedMessageSizeName())->first().convertedValue( p_unit ) &#xD;&#xA;&#xD;&#xA;context NamedElement def :allowedMessageSizeMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMinPropertyValues( memoryPropertiesPropertySetName(), allowedMessageSizeName())->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :assignTime( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerPropertyValues( memoryPropertiesPropertySetName(), assignTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :baseAddress() :&#xD;&#xA;&#x9;Integer = integerValues( memoryPropertiesPropertySetName(), baseAddressName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :readTimeMax( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMaxPropertyValues( memoryPropertiesPropertySetName(), readTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :readTimeMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerRangeMinPropertyValues( memoryPropertiesPropertySetName(), readTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :sourceCodeSize( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerPropertyValues( memoryPropertiesPropertySetName(), sourceCodeSizeName())->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :sourceDataSize( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerPropertyValues( memoryPropertiesPropertySetName(), sourceDataSizeName())->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :sourceHeapSize( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerPropertyValues( memoryPropertiesPropertySetName(), sourceHeapSizeName())->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :sourceStackSize( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerPropertyValues( memoryPropertiesPropertySetName(), sourceStackSizeName())->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :wordSize( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerPropertyValues( memoryPropertiesPropertySetName(), wordSizeName())->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def :wordSpace() :&#xD;&#xA;&#x9;Integer = integerValues( memoryPropertiesPropertySetName(), wordSpaceName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :writeTimesMax( p_unit : String ) :&#xD;&#xA;&#x9;OrderedSet( Real ) = integerRangeMaxPropertyValues( memoryPropertiesPropertySetName(), writeTimeName() )->collect( convertedValue( p_unit ) )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;context NamedElement def :writeTimesMin( p_unit : String ) :&#xD;&#xA;&#x9;OrderedSet( Real ) = integerRangeMinPropertyValues( memoryPropertiesPropertySetName(), writeTimeName() )->collect( convertedValue( p_unit ) )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;-------------------- SEI ------------------------&#xD;&#xA;context NamedElement def : mipsCapacity() :&#xD;&#xA;&#x9;Real = realValues( seiPropertySetName(), mipsCapacityName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def : mipsBudget() :&#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(),mipsBudgetName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :ramCapacity() :&#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(),ramCapacityName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :ramBudget() :&#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(),ramBudgetName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def: romCapacity() :&#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(),romCapacityName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def: romBudget() :&#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(),romBudgetName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :powerCapacity() :&#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(),powerCapacityName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :powerBudget() :&#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(),powerBudgetName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :powerSupply() :&#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(),powerSupplyName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :bandWidthCapacity() :&#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(),bandWidthCapacityName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :ramActual() :&#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(),ramActualName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :romActual() :&#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(),romActualName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :streamMissRate() : &#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(),streamMissRateName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def : netWeight() :&#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(),netWeightName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :grossWeight() : &#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(),grossWeightName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def :weightLimit() : &#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(),weightLimitName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def : securityLevel() :&#xD;&#xA;&#x9;Integer = integerValues(seiPropertySetName(),securityLevelName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def : safetyCriticality() :&#xD;&#xA;&#x9;Integer = integerValues(seiPropertySetName(),safetyCriticalityName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def : priority() :&#xD;&#xA;&#x9;Integer = integerValues(seiPropertySetName(), priorityName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def: cycleTime( p_unit : String ) :&#xD;&#xA;&#x9;Real = integerPropertyValues( seiPropertySetName(), cycleTimeName() )->first().convertedValue( p_unit )&#xD;&#xA;&#xD;&#xA;context NamedElement def: speedScalingFactor() :&#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(), speedScalingFactorName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def: cyclesPerInstruction() :&#xD;&#xA;&#x9;Real = realValues(seiPropertySetName(),cyclesPerInstructionName())->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def : dataRepresentation() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues(seiPropertySetName(), dataRepresentationName() )->first()&#xD;&#xA;&#xD;&#xA;context NamedElement def : protocolQoS() :&#xD;&#xA;&#x9;PropertyExpression = propertyValues(seiPropertySetName(), protocolQoSName() )->first()&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : isBoundTo( p_component : instance::ComponentInstance ) :&#xD;&#xA;&#x9;Boolean = actualProcessorBinding() = p_component&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : allThreadsBoundToProcessor() :&#xD;&#xA;&#x9; Set(instance::ComponentInstance) = instance::ComponentInstance.allInstances()->select(isThread())->select( isBoundTo(self ) )&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : allPeriodsOfThreadsBoundToProcessor( p_unit : String ) :&#xD;&#xA;&#x9;OrderedSet( Real ) = allThreadsBoundToProcessor()->collect( period( p_unit ) )->asOrderedSet()&#xD;&#xA;&#xD;&#xA;-- Returns the sum of all maximum compute exec time of threads bound to self.&#xD;&#xA;context instance::ComponentInstance def : sumExecTimeMaxOfThreadsBoundToProcessor( p_unit : String ) :&#xD;&#xA;&#x9;Real = allThreadsBoundToProcessor()->collect( computeExecutionTimeMax(  msUnit() ) )->sum()&#xD;&#xA;&#xD;&#xA;-- Ensures that the maximum of bound threads period is smaller than the sum of the max compute exec time of bound threads.&#xD;&#xA;context instance::ComponentInstance def : threadsPeriodicityNotViolated() :&#xD;&#xA;&#x9;Boolean = allPeriodsOfThreadsBoundToProcessor( msUnit() )->select( v : Real |( v &lt; sumExecTimeMaxOfThreadsBoundToProcessor(  msUnit() ) ) )->isEmpty()&#xD;&#xA;&#xD;&#xA;endpackage"/>
    </libraries>
    <libraries id="platform:/config/fr.openpeople.ide.settings/ocl/libComponentFPGA.ocl" name="libComponentFPGA.ocl">
      <expression id="0dd464fa-8c61-4b15-b1d8-e4fe092fa986" language="fr.labsticc.framework.constraints.ocl" text="-- *****************************************************************************************&#xD;&#xA;-- ** Copyright (c) 2009 Lab-STICC, Universit&#xe9; de Bretagne-Sud.                           **&#xD;&#xA;-- ** All rights reserved. This program and the accompanying materials                    **&#xD;&#xA;-- ** are made available under the terms of the CeCILL-B FREE SOFTWARE LICENSE AGREEMENT  **&#xD;&#xA;-- ** which accompanies this distribution, and is available at                            **&#xD;&#xA;-- ** http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html                         **&#xD;&#xA;-- **                                                                                     **&#xD;&#xA;-- ** Contributors:                                                                       **&#xD;&#xA;-- **   Dominique BLOUIN (Lab-STICC, UBS)                                                    **&#xD;&#xA;-- *****************************************************************************************&#xD;&#xA;&#xD;&#xA;package aadl2&#xD;&#xA;&#xD;&#xA;--context ECore::EString &#xD;&#xA;&#x9;--def: startsWith( p_string : String ) : &#xD;&#xA;&#x9;&#x9;--Boolean =&#xD;&#xA;        &#x9;--p_string.size() &lt;= size() and substring( 1, p_string.size() ) = p_string&#xD;&#xA; &#xD;&#xA;--context String &#xD;&#xA;&#x9;--def: endsWith( p_string : String ) :&#xD;&#xA;&#x9;&#x9;--Boolean =&#xD;&#xA;        &#x9;--let&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;--start : Integer = size() - p_string.size() + 1 &#xD;&#xA;&#x9;&#x9;&#x9;--in&#xD;&#xA;            &#x9;--start > 0 and substring( start, size() ) = p_string&#xD;&#xA;&#xD;&#xA;context SystemImplementation def : fpgaSubcomponentsCle() : &#xD;&#xA;&#x9;Bag( Subcomponent ) = &#xD;&#xA;&#x9;&#x9;ownedSubcomponent->select( oclIsKindOf( ProcessorSubcomponent ) )->&#xD;&#xA;&#x9;&#x9;&#x9;select( isOfType( 'IP_Core' ) or isOfType( 'DSP_Block' ) or isOfType( 'FPGA_Processor' ) )->&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;collect( oclAsType( Subcomponent ) )->&#xD;&#xA;&#x9;&#x9;&#x9;union( ownedSubcomponent->select( oclIsKindOf( DeviceSubcomponent ) )->&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;select( isOfType( 'FPGA_Device' ) ) )->flatten()&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : isIP() :&#xD;&#xA;&#x9;Boolean = isProcessor() and isOfType( 'generic_fpga::IP_Core' )&#xD;&#xA;&#xD;&#xA;endpackage"/>
    </libraries>
    <libraries id="platform:/config/fr.openpeople.ide.settings/ocl/libPropertyFPGA.ocl" name="libPropertyFPGA.ocl">
      <expression id="a923972f-464e-4b18-af8b-e8fdbc6c8bc6" language="fr.labsticc.framework.constraints.ocl" text="MainModel : http:///AADL/property&#xD;&#xA;&#xD;&#xA;-- *****************************************************************************************&#xD;&#xA;-- ** Copyright (c) 2009 Lab-STICC, Universit&#xe9; de Bretagne-Sud.                           **&#xD;&#xA;-- ** All rights reserved. This program and the accompanying materials                    **&#xD;&#xA;-- ** are made available under the terms of the CeCILL-B FREE SOFTWARE LICENSE AGREEMENT  **&#xD;&#xA;-- ** which accompanies this distribution, and is available at                            **&#xD;&#xA;-- ** http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html                         **&#xD;&#xA;-- **                                                                                     **&#xD;&#xA;-- ** Contributors:                                                                       **&#xD;&#xA;-- **   Dominique BLOUIN (Lab-STICC, UBS)                                                    **&#xD;&#xA;-- *****************************************************************************************&#xD;&#xA;&#xD;&#xA;package aadl2&#xD;&#xA;&#xD;&#xA;context NamedElement def : FPGA_PROPERTIES_PROPERTY_SET_NAME : &#xD;&#xA;&#x9;String = 'FPGA_Properties'&#xD;&#xA;&#xD;&#xA;context NamedElement def : FPGA_CLE_AVAILABLE_PROP_NAME : &#xD;&#xA;&#x9;String = 'CLE_Available'&#xD;&#xA;&#xD;&#xA;context NamedElement def : FPGA_CLE_OCCUPIED_PROP_NAME : &#xD;&#xA;&#x9;String = 'CLE_Occupied'&#xD;&#xA;&#xD;&#xA;context NamedElement def : FPGA_CLE_REQUIRED_PROP_NAME : &#xD;&#xA;&#x9;String = 'CLE_Required'&#xD;&#xA;&#xD;&#xA;context NamedElement def : CLE_UNIT :&#xD;&#xA;&#x9;String = 'cle'&#xD;&#xA;&#xD;&#xA;context NamedElement def : KCLE_UNIT :&#xD;&#xA;&#x9;String = 'kcle'&#xD;&#xA;&#xD;&#xA;context NamedElement def : fpgaSurfaceRequiredCle() :&#xD;&#xA;&#x9;Real = &#xD;&#xA;&#x9;&#x9;if oclIsKindOf( ThreadClassifier ) or oclIsKindOf( ThreadSubcomponent ) or&#xD;&#xA;&#x9;&#x9;&#x9;( oclIsKindOf( instance::ComponentInstance ) and oclAsType( instance::ComponentInstance ).isThread() ) then&#xD;&#xA;&#x9;&#x9;&#x9;integerPropertyValues( FPGA_PROPERTIES_PROPERTY_SET_NAME, FPGA_CLE_REQUIRED_PROP_NAME )->first().convertedValue( CLE_UNIT )&#xD;&#xA;&#x9;&#x9;else&#xD;&#xA;&#x9;&#x9;&#x9;null&#xD;&#xA;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context SystemImplementation def : fpgaSurfaceAvailableCle() :&#xD;&#xA;&#x9;Real = &#xD;&#xA;&#x9;&#x9;integerPropertyValues( FPGA_PROPERTIES_PROPERTY_SET_NAME, FPGA_CLE_AVAILABLE_PROP_NAME )->first().convertedValue( CLE_UNIT )&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : fpgaSurfaceAvailableCle() :&#xD;&#xA;&#x9;Real = &#xD;&#xA;&#x9;&#x9;integerPropertyValues( FPGA_PROPERTIES_PROPERTY_SET_NAME, FPGA_CLE_AVAILABLE_PROP_NAME )->first().convertedValue( CLE_UNIT )&#xD;&#xA;&#xD;&#xA;context instance::ComponentInstance def : fpgaSurfaceOccuppiedCle() :&#xD;&#xA;&#x9;Real = rootParent().oclAsType( instance::ComponentInstance ).&#xD;&#xA;&#x9;&#x9;allContainedComponents( ComponentCategory::thread )->&#xD;&#xA;&#x9;&#x9;&#x9;select( isBoundTo( self ) )->&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;collect( fpgaSurfaceRequiredCle() )->sum()&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;endpackage"/>
    </libraries>
    <libraries id="platform:/config/fr.openpeople.ide.settings/ocl/libPropertyOP.ocl" name="libPropertyOP.ocl">
      <expression id="cd912ba5-ba4a-4a3c-b7a7-adf56d33f14c" language="fr.labsticc.framework.constraints.ocl" text="-- *****************************************************************************************&#xD;&#xA;-- ** Copyright (c) 2009 Lab-STICC, Universit&#xe9; de Bretagne-Sud.                           **&#xD;&#xA;-- ** All rights reserved. This program and the accompanying materials                    **&#xD;&#xA;-- ** are made available under the terms of the CeCILL-B FREE SOFTWARE LICENSE AGREEMENT  **&#xD;&#xA;-- ** which accompanies this distribution, and is available at                            **&#xD;&#xA;-- ** http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html                         **&#xD;&#xA;-- **                                                                                     **&#xD;&#xA;-- ** Contributors:                                                                       **&#xD;&#xA;-- **   Dominique BLOUIN (Lab-STICC, UBS)                                                    **&#xD;&#xA;-- *****************************************************************************************&#xD;&#xA;&#xD;&#xA;package aadl2&#xD;&#xA;context PropertyHolder def : opPropertySetName() : &#xD;&#xA;&#x9;String = 'Basic_OP_Properties'&#xD;&#xA;&#xD;&#xA;endpackage"/>
    </libraries>
    <libraries id="platform:/config/fr.openpeople.ide.settings/ocl/libPropertyPower.ocl" name="libPropertyPower.ocl">
      <expression id="ad68ba55-a3fe-4ac0-9c66-e6d52f2f9317" language="fr.labsticc.framework.constraints.ocl" text="-- *****************************************************************************************&#xD;&#xA;-- ** Copyright (c) 2011 Lab-STICC, Universit&#xe9; de Bretagne-Sud.                           **&#xD;&#xA;-- ** All rights reserved. This program and the accompanying materials                    **&#xD;&#xA;-- ** are made available under the terms of the CeCILL-B FREE SOFTWARE LICENSE AGREEMENT  **&#xD;&#xA;-- ** which accompanies this distribution, and is available at                            **&#xD;&#xA;-- ** http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html                         **&#xD;&#xA;-- **                                                                                     **&#xD;&#xA;-- ** Contributors:                                                                       **&#xD;&#xA;-- **   Dominique BLOUIN (Lab-STICC, UBS)                                                 **&#xD;&#xA;-- *****************************************************************************************&#xD;&#xA;&#xD;&#xA;package aadl2&#xD;&#xA;&#xD;&#xA;context NamedElement def : POWER_PROPERTY_SET_NAME : &#xD;&#xA;&#x9;String = 'Power_Properties'&#xD;&#xA;&#xD;&#xA;context NamedElement def : POWER_TOTAL_PROP_NAME : &#xD;&#xA;&#x9;String = 'Power_Tot'&#xD;&#xA;&#xD;&#xA;context NamedElement def : POWER_STAT_PROP_NAME : &#xD;&#xA;&#x9;String = 'Power_Static'&#xD;&#xA;&#xD;&#xA;context NamedElement def : POWER_DYN_PROP_NAME : &#xD;&#xA;&#x9;String = 'Power_Dynamic'&#xD;&#xA;&#xD;&#xA;context NamedElement def : ENERGY_PROP_NAME : &#xD;&#xA;&#x9;String = 'Energy_Range'&#xD;&#xA;&#xD;&#xA;-- Units --&#xD;&#xA;-- Power&#xD;&#xA;context NamedElement def : PW_UNIT :&#xD;&#xA;&#x9;String = 'pW'&#xD;&#xA;&#xD;&#xA;context NamedElement def : NW_UNIT :&#xD;&#xA;&#x9;String = 'nW'&#xD;&#xA;&#xD;&#xA;context NamedElement def : UW_UNIT :&#xD;&#xA;&#x9;String = 'uW'&#xD;&#xA;&#xD;&#xA;context NamedElement def : MW_UNIT :&#xD;&#xA;&#x9;String = 'mW'&#xD;&#xA;&#xD;&#xA;context NamedElement def : W_UNIT :&#xD;&#xA;&#x9;String = 'W'&#xD;&#xA;&#xD;&#xA;context NamedElement def : KW_UNIT :&#xD;&#xA;&#x9;String = 'KW'&#xD;&#xA;&#xD;&#xA;-- Energy&#xD;&#xA;context NamedElement def : PJ_UNIT :&#xD;&#xA;&#x9;String = 'pJ'&#xD;&#xA;&#xD;&#xA;context NamedElement def : NJ_UNIT :&#xD;&#xA;&#x9;String = 'nJ'&#xD;&#xA;&#xD;&#xA;context NamedElement def : UJ_UNIT :&#xD;&#xA;&#x9;String = 'uJ'&#xD;&#xA;&#xD;&#xA;context NamedElement def : MJ_UNIT :&#xD;&#xA;&#x9;String = 'mJ'&#xD;&#xA;&#xD;&#xA;context NamedElement def : J_UNIT :&#xD;&#xA;&#x9;String = 'J'&#xD;&#xA;&#xD;&#xA;context NamedElement def : KJ_UNIT :&#xD;&#xA;&#x9;String = 'KJ'&#xD;&#xA;&#xD;&#xA;context NamedElement def : energyMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = &#xD;&#xA;&#x9;&#x9;let &#xD;&#xA;&#x9;&#x9;&#x9;value : RealLiteral = firstRealRangeMinPropertyValue( POWER_PROPERTY_SET_NAME, ENERGY_PROP_NAME )&#xD;&#xA;&#x9;&#x9;in &#xD;&#xA;&#x9;&#x9;&#x9;if value.oclIsUndefined() then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;null&#xD;&#xA;&#x9;&#x9;&#x9;else &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;value.convertedValue( p_unit )&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context NamedElement def : energyMax( p_unit : String  ) :&#xD;&#xA;&#x9;Real = &#xD;&#xA;&#x9;&#x9;let &#xD;&#xA;&#x9;&#x9;&#x9;value : RealLiteral = firstRealRangeMaxPropertyValue( POWER_PROPERTY_SET_NAME, ENERGY_PROP_NAME )&#xD;&#xA;&#x9;&#x9;in &#xD;&#xA;&#x9;&#x9;&#x9;if value.oclIsUndefined() then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;null&#xD;&#xA;&#x9;&#x9;&#x9;else &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;value.convertedValue( p_unit )&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context NamedElement def : powerStatMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = &#xD;&#xA;&#x9;&#x9;let &#xD;&#xA;&#x9;&#x9;&#x9;value : RealLiteral = firstRealRangeMinPropertyValue( POWER_PROPERTY_SET_NAME, POWER_STAT_PROP_NAME )&#xD;&#xA;&#x9;&#x9;in &#xD;&#xA;&#x9;&#x9;&#x9;if value.oclIsUndefined() then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;null&#xD;&#xA;&#x9;&#x9;&#x9;else &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;value.convertedValue( p_unit )&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context NamedElement def : powerStatMax( p_unit : String  ) :&#xD;&#xA;&#x9;Real = &#xD;&#xA;&#x9;&#x9;let &#xD;&#xA;&#x9;&#x9;&#x9;value : RealLiteral = firstRealRangeMaxPropertyValue( POWER_PROPERTY_SET_NAME, POWER_STAT_PROP_NAME )&#xD;&#xA;&#x9;&#x9;in &#xD;&#xA;&#x9;&#x9;&#x9;if value.oclIsUndefined() then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;null&#xD;&#xA;&#x9;&#x9;&#x9;else &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;value.convertedValue( p_unit )&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context NamedElement def : powerDynMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = &#xD;&#xA;&#x9;&#x9;let &#xD;&#xA;&#x9;&#x9;&#x9;value : RealLiteral = firstRealRangeMinPropertyValue( POWER_PROPERTY_SET_NAME, POWER_DYN_PROP_NAME )&#xD;&#xA;&#x9;&#x9;in &#xD;&#xA;&#x9;&#x9;&#x9;if value.oclIsUndefined() then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;null&#xD;&#xA;&#x9;&#x9;&#x9;else &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;value.convertedValue( p_unit )&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context NamedElement def : powerDynMax( p_unit : String  ) :&#xD;&#xA;&#x9;Real = &#xD;&#xA;&#x9;&#x9;let &#xD;&#xA;&#x9;&#x9;&#x9;value : RealLiteral = firstRealRangeMaxPropertyValue( POWER_PROPERTY_SET_NAME, POWER_DYN_PROP_NAME )&#xD;&#xA;&#x9;&#x9;in &#xD;&#xA;&#x9;&#x9;&#x9;if value.oclIsUndefined() then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;null&#xD;&#xA;&#x9;&#x9;&#x9;else &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;value.convertedValue( p_unit )&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context NamedElement def : powerTotalMin( p_unit : String ) :&#xD;&#xA;&#x9;Real = &#xD;&#xA;&#x9;&#x9;let &#xD;&#xA;&#x9;&#x9;&#x9;value : RealLiteral = firstRealRangeMinPropertyValue( POWER_PROPERTY_SET_NAME, POWER_TOTAL_PROP_NAME )&#xD;&#xA;&#x9;&#x9;in &#xD;&#xA;&#x9;&#x9;&#x9;if value.oclIsUndefined() then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;null&#xD;&#xA;&#x9;&#x9;&#x9;else &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;value.convertedValue( p_unit )&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;context NamedElement def : powerTotalMax( p_unit : String ) :&#xD;&#xA;&#x9;Real = &#xD;&#xA;&#x9;&#x9;let &#xD;&#xA;&#x9;&#x9;&#x9;value : RealLiteral = firstRealRangeMaxPropertyValue( POWER_PROPERTY_SET_NAME, POWER_TOTAL_PROP_NAME )&#xD;&#xA;&#x9;&#x9;in &#xD;&#xA;&#x9;&#x9;&#x9;if value.oclIsUndefined() then&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;null&#xD;&#xA;&#x9;&#x9;&#x9;else &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;value.convertedValue( p_unit )&#xD;&#xA;&#x9;&#x9;&#x9;endif&#xD;&#xA;&#xD;&#xA;endpackage"/>
    </libraries>
    <interpreter id="ocl_int_service" name="OCL Interpreter Service" serviceClass="fr.labsticc.framework.constraints.ocl.service.OCLInterpretationAS" providerId="fr.labsticc.framework.constraints.ocl.service"/>
    <persister id="85f3b6c7-b640-4677-85ef-a84e93ee47c2" name="OCL Persistence Service" serviceClass="fr.labsticc.framework.constraints.ocl.service.OCLResourcePersistenceAS" providerId="fr.labsticc.framework.constraints.ocl.service"/>
    <viewer id="1102107e-e892-4708-a878-2c11b5e47c27" name="OCL Viewer Configuration" serviceClass="fr.labsticc.framework.constraints.ocl.view.OCLViewerConfiguration" providerId="fr.labsticc.framework.constraints.ocl.view"/>
  </languages>
  <languages xsi:type="cst:FormalConstraintLanguage" id="fr.labsticc.framework.constraints.lute" name="Lute">
    <libraries id="platform:/config/fr.openpeople.ide.settings/lute/default/libStandard.lute" name="libStandard.lute" default="true">
      <expression id="753b6bd6-6b48-4f30-911e-b916de75e52a" language="fr.labsticc.framework.constraints.lute" text="-- *****************************************************************************************&#xD;&#xA;-- ** Copyright (c) 2012 Lab-STICC, Universit&#xe9; de Bretagne-Sud.                           **&#xD;&#xA;-- ** All rights reserved. This program and the accompanying materials                    **&#xD;&#xA;-- ** are made available under the terms of the CeCILL-B FREE SOFTWARE LICENSE AGREEMENT  **&#xD;&#xA;-- ** which accompanies this distribution, and is available at                            **&#xD;&#xA;-- ** http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html                         **&#xD;&#xA;-- **                                                                                     **&#xD;&#xA;-- ** Contributors:                                                                       **&#xD;&#xA;-- **   Dominique BLOUIN (Lab-STICC, UBS)                                                 **&#xD;&#xA;-- *****************************************************************************************&#xD;&#xA;&#xD;&#xA;-- Properties&#xD;&#xA;DEPLOY_PROPERTY_SET_NAME := &quot;Deployment_Properties::&quot;;&#xD;&#xA;ACTUAL_PROCESSOR_BINDING_PROP_NAME := Concat( DEPLOY_PROPERTY_SET_NAME, &quot;Actual_Processor_Binding&quot; );&#xD;&#xA;&#xD;&#xA;COMM_PROPERTY_SET_NAME := &quot;Communication_Properties::&quot;;&#xD;&#xA;LATENCY_PROP_NAME := Concat( COMM_PROPERTY_SET_NAME, &quot;Latency&quot; );&#xD;&#xA;ACTUAL_LATENCY_PROP_NAME := Concat( COMM_PROPERTY_SET_NAME, &quot;Actual_Latency&quot; );&#xD;&#xA;&#xD;&#xA;-- Time Units Constants&#xD;&#xA;PSEC_UNIT := &quot;ps&quot;;&#xD;&#xA;NSEC_UNIT := &quot;ns&quot;;&#xD;&#xA;USEC_UNIT := &quot;us&quot;;&#xD;&#xA;MSEC_UNIT := &quot;ms&quot;;&#xD;&#xA;SEC_UNIT := &quot;sec&quot;;&#xD;&#xA;HOUR_UNIT := &quot;hr&quot;;&#xD;&#xA;MIN_UNIT := &quot;min&quot;;&#xD;&#xA;&#xD;&#xA;Processor_Binding( thread ) := Property( thread, ACTUAL_PROCESSOR_BINDING_PROP_NAME );&#xD;&#xA;First_Processor_Binding( thread ) := First( Property( thread, ACTUAL_PROCESSOR_BINDING_PROP_NAME ) );&#xD;&#xA;&#xD;&#xA;Latency( element, unit ) := Property( element, LATENCY_PROP_NAME, unit ); &#xD;&#xA;Actual_Latency( element, unit ) := Property( element, ACTUAL_LATENCY_PROP_NAME, unit ); &#xD;&#xA;&#x9;"/>
    </libraries>
    <libraries id="platform:/config/fr.openpeople.ide.settings/lute/libFPGA.lute" name="libFPGA.lute">
      <expression id="5f1a9888-f22f-46dd-879b-ac691e41da7d" language="fr.labsticc.framework.constraints.lute" text="-- *****************************************************************************************&#xD;&#xA;-- ** Copyright (c) 2012 Lab-STICC, Universit&#xe9; de Bretagne-Sud.                           **&#xD;&#xA;-- ** All rights reserved. This program and the accompanying materials                    **&#xD;&#xA;-- ** are made available under the terms of the CeCILL-B FREE SOFTWARE LICENSE AGREEMENT  **&#xD;&#xA;-- ** which accompanies this distribution, and is available at                            **&#xD;&#xA;-- ** http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html                         **&#xD;&#xA;-- **                                                                                     **&#xD;&#xA;-- ** Contributors:                                                                       **&#xD;&#xA;-- **   Dominique BLOUIN (Lab-STICC, UBS)                                                 **&#xD;&#xA;-- *****************************************************************************************&#xD;&#xA;&#xD;&#xA;IP_Set := { proc in Processor_Set | Is_Of_Type( proc, &quot;generic_fpga::IP_Core&quot; ) };&#xD;&#xA;&#xD;&#xA;Is_IP( proc ) := Member( proc, IP_Set );&#xD;&#xA;&#xD;&#xA;FPGA_Property_Set_Name := &quot;FPGA_Properties::&quot;;&#xD;&#xA;&#xD;&#xA;CLE_Required( thread ) := Property( thread, Concat( FPGA_Property_Set_Name, &quot;CLE_Required&quot; ) );&#xD;&#xA;CLE_Available( thread ) := Property( thread, Concat( FPGA_Property_Set_Name, &quot;CLE_Available&quot; ) );&#xD;&#xA;&#xD;&#xA;"/>
    </libraries>
    <libraries id="platform:/config/fr.openpeople.ide.settings/lute/libPower.lute" name="libPower.lute">
      <expression id="3499c1e0-0c02-4962-853f-0f5378d2a4c3" language="fr.labsticc.framework.constraints.lute" text="-- *****************************************************************************************&#xD;&#xA;-- ** Copyright (c) 2012 Lab-STICC, Universit&#xe9; de Bretagne-Sud.                           **&#xD;&#xA;-- ** All rights reserved. This program and the accompanying materials                    **&#xD;&#xA;-- ** are made available under the terms of the CeCILL-B FREE SOFTWARE LICENSE AGREEMENT  **&#xD;&#xA;-- ** which accompanies this distribution, and is available at                            **&#xD;&#xA;-- ** http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html                         **&#xD;&#xA;-- **                                                                                     **&#xD;&#xA;-- ** Contributors:                                                                       **&#xD;&#xA;-- **   Dominique BLOUIN (Lab-STICC, UBS)                                                 **&#xD;&#xA;-- *****************************************************************************************&#xD;&#xA;&#xD;&#xA;-- Constants&#xD;&#xA;&#xD;&#xA;-- Properties&#xD;&#xA;POWER_PROPERTY_SET_NAME := &quot;Power_Properties::&quot;;&#xD;&#xA;POWER_TOTAL_PROP_NAME := Concat( POWER_PROPERTY_SET_NAME, &quot;Power_Tot&quot; );&#xD;&#xA;POWER_STAT_PROP_NAME := Concat( POWER_PROPERTY_SET_NAME, &quot;Power_Static&quot; );&#xD;&#xA;POWER_DYN_PROP_NAME := Concat( POWER_PROPERTY_SET_NAME, &quot;Power_Dynamic&quot; );&#xD;&#xA;ENERGY_PROP_NAME := Concat( POWER_PROPERTY_SET_NAME, &quot;Energy_Range&quot; );&#xD;&#xA;&#xD;&#xA;-- Units --&#xD;&#xA;&#xD;&#xA;-- Power&#xD;&#xA;PW_UNIT := &quot;pW&quot;;&#xD;&#xA;NW_UNIT := &quot;nW&quot;;&#xD;&#xA;UW_UNIT := &quot;uW&quot;;&#xD;&#xA;MW_UNIT := &quot;mW&quot;;&#xD;&#xA;W_UNIT := &quot;W&quot;;&#xD;&#xA;KW_UNIT := &quot;KW&quot;;&#xD;&#xA;&#xD;&#xA;-- Energy&#xD;&#xA;PJ_UNIT := &quot;pJ&quot;;&#xD;&#xA;NJ_UNIT := &quot;nJ&quot;;&#xD;&#xA;UJ_UNIT := &quot;uJ&quot;;&#xD;&#xA;MJ_UNIT := &quot;mJ&quot;;&#xD;&#xA;J_UNIT := &quot;J&quot;;&#xD;&#xA;KJ_UNIT := &quot;KJ&quot;;&#xD;&#xA;&#xD;&#xA;-- Property Helpers&#xD;&#xA;Energy_Min( comp, unit ) := Lower( Property( comp, ENERGY_PROP_NAME, unit ) );&#xD;&#xA;Energy_Max( comp, unit ) := Upper( Property( comp, ENERGY_PROP_NAME, unit ) );&#xD;&#xA;&#xD;&#xA;Power_Stat_Min( comp, unit ) := Lower( Property( comp, POWER_STAT_PROP_NAME, unit ) );&#xD;&#xA;Power_Stat_Max( comp, unit ) := Upper( Property( comp, POWER_STAT_PROP_NAME, unit ) );&#xD;&#xA;&#xD;&#xA;Power_Dyn_Min( comp, unit ) := Lower( Property( comp, POWER_DYN_PROP_NAME, unit ) );&#xD;&#xA;Power_Dyn_Max( comp, unit ) := Upper( Property( comp, POWER_DYN_PROP_NAME, unit ) );&#xD;&#xA;&#xD;&#xA;Power_Tot_Min( comp, unit ) := Lower( Property( comp, POWER_TOTAL_PROP_NAME, unit ) );&#xD;&#xA;Power_Tot_Max( comp, unit ) := Upper( Property( comp, POWER_TOTAL_PROP_NAME, unit ) );&#xD;&#xA;&#x9;&#x9;&#x9;"/>
    </libraries>
    <interpreter id="lute_int_service" name="Lute Interpreter Service" serviceClass="fr.labsticc.framework.constraints.lute.service.LuteInterpretationAS" providerId="fr.labsticc.framework.constraints.lute.service"/>
    <viewer id="4c51dce4-827a-4ebb-86e1-41aea3848d83" name="Lute Viewer Configuration" serviceClass="fr.labsticc.framework.constraints.lute.view.LuteViewerConfiguration" providerId="fr.labsticc.framework.constraints.lute.view"/>
  </languages>
</cst:ConstraintLanguagesSpecification>
